// Code generated by https://github.com/foomo/gocontentful - DO NOT EDIT.
{{ $cfg := . }}{{ $contentTypes := .ContentTypes }}{{ $locales := .Locales }}package {{ .PackageName }}

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"html"
	"io"
	"regexp"
	"strings"
	"time"
	"github.com/foomo/contentful"
	"golang.org/x/sync/errgroup"
)

type Locale string

type ClientMode string

const (
	ClientModeCDA ClientMode = "CDA"
	ClientModeCPA ClientMode = "CPA"
	ClientModeCMA ClientMode = "CMA"
)

{{ range $index , $locale := $locales }}const SpaceLocale{{ onlyLetters $locale.Name }} Locale = "{{ $locale.Code }}"
{{ end }}
{{ range $index , $locale := $locales }}{{ if $locale.Default }}const defaultLocale Locale = SpaceLocale{{ onlyLetters $locale.Name }}{{ end }}
{{ end }}var localeFallback = map[Locale]Locale{ {{ range $index, $locale := $locales }}{{if $locale.FallbackCode}} SpaceLocale{{ onlyLetters $locale.Name }}: {{ range $indexSearch, $localeSearch := $locales }}{{ if eq $localeSearch.Code $locale.FallbackCode}}SpaceLocale{{ onlyLetters $localeSearch.Name }}{{ end }}{{ end }}, {{ else }}SpaceLocale{{ onlyLetters $locale.Name }}: "", {{ end }}{{ end }}}

const (
	assetPageSize = 1000
	assetWorkerType = "_asset"
)

const cacheUpdateConcurrency = 4

const (
	LogDebug = 0
	LogInfo = 1
	LogWarn = 2
	LogError = 3
)

var (
	ErrLocaleUnsupported = errors.New("Locale not supported by this space")
	ErrNotSet            = errors.New("Field value not set")
	ErrNotSetNoFallback  = errors.New("Field value not set and no fallback locale available")
	ErrRefNotIncludes    = errors.New("Referenced entry not found in includes")
	ErrNoTypeOfRefEntry  = errors.New("Couldn't get contentType of referenced entry")
	ErrNoTypeOfRefAsset  = errors.New("Couldn't get contentType of referenced asset")
	InfoCachedAllEntries = "Cached all entries of content type"
	InfoCachedAllAssets  = "Cached all assets"
	InfoUpdateCacheTime = "Space caching done, time recorded"
)

var spaceContentTypes = []string{ {{ range $index , $contentType := $contentTypes }}ContentType{{ firstCap $contentType.Sys.ID }}, {{ end }} }

type ContentfulClient struct {
	Cache  *ContentfulCache
	clientMode ClientMode
	Client     *contentful.Contentful
	debug      bool
	locales    []Locale
	logFn      func(
			fields map[string]interface{},
			level int,
			args ...interface{},
	)
	logLevel           int
	optimisticPageSize uint16 // Start downloading entries at this page size
	SpaceID            string
}

type ContentfulCache struct {
	Assets map[string]*contentful.Asset
	ContentTypes []string
	EntryMaps CacheEntryMaps
	IdContentTypeMap map[string]string
	ParentMap map[string][]EntryReference // Maps each entry ID to its parents' IDs
}

type EntryReference struct {
	ContentType string
	ID string
	VO interface{}
}

type CacheEntryMaps struct {
	{{ range $index , $contentType := $contentTypes }}	{{ firstCap $contentType.Sys.ID }} map[string]*Cf{{ firstCap $contentType.Sys.ID }}
	{{ end }}
}

type ContentTypeResult struct {
	EntryID     string
	ContentType string
	References  map[string][]EntryReference
}

func NewContentfulClient(spaceID string, clientMode ClientMode, clientKey string, optimisticPageSize uint16, logFn func(fields map[string]interface{}, level int, args ...interface{}), logLevel int, debug bool) (*ContentfulClient, error) {
	if spaceID == "" {
		return nil, errors.New("NewContentfulClient: SpaceID cannot be empty")
	}
	if clientKey == "" {
		return nil, errors.New("NewContentfulClient: Please provide an API key")
	}
	apiClient, err := getContentfulAPIClient(clientMode, clientKey)
	if err != nil {
		return nil, err
	}
	cc := &ContentfulClient{
		clientMode:         clientMode,
		Client:             apiClient,
		debug:              debug,
		locales:			[]Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }}, {{ end }} },
		logFn:              logFn,
		logLevel:           logLevel,
		optimisticPageSize: optimisticPageSize,
		SpaceID:            spaceID,
	}
	if _, err := cc.Client.Spaces.Get(spaceID); err != nil {
		if _, ok := err.(contentful.NotFoundError); ok {
			return nil, errors.New("NewContentfulClient: That is not the space you're looking for")
		}
		return nil, fmt.Errorf("NewContentfulClient: %w", err)
	}
	return cc, nil
}

func getContentfulAPIClient(clientMode ClientMode, clientKey string) (*contentful.Contentful, error) {
	switch clientMode {
	case ClientModeCDA:
		return contentful.NewCDA(clientKey), nil
	case ClientModeCPA:
		return contentful.NewCPA(clientKey), nil
	case ClientModeCMA:
		return contentful.NewCMA(clientKey), nil
	}
	return nil, errors.New("NewContentfulClient: Unknown ClientMode")
}

func updateCacheForContentType(ctx context.Context, results chan ContentTypeResult, cc *ContentfulClient, tempCache *ContentfulCache, contentType string) error {
	if err := ctx.Err(); err != nil {
		return err
	}
	switch contentType {
	{{ range $index , $contentType := $contentTypes }}
	case ContentType{{ firstCap $contentType.Sys.ID }}:
		all{{ firstCap $contentType.Sys.ID }}, err := cc.cacheAll{{ firstCap $contentType.Sys.ID }}(ctx, results)
		if err != nil {
			return err
		}
		tempCache.EntryMaps.{{ firstCap $contentType.Sys.ID }} = all{{ firstCap $contentType.Sys.ID }}
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType":"{{ $contentType.Sys.ID }}", "method": "updateCacheForContentType", "size":len(all{{ firstCap $contentType.Sys.ID }})}, LogInfo, InfoCachedAllEntries)
		}
	{{ end }}
	case assetWorkerType:
		allAssets, err := cc.getAllAssets(false)
		if err != nil {
			return err
		}
		tempCache.Assets = allAssets
		if cc.logFn != nil && cc.logLevel <= LogInfo {
			cc.logFn(map[string]interface{}{"contentType": "asset", "method": "updateCacheForContentType", "size": len(allAssets)}, LogInfo, InfoCachedAllAssets)
		}
	}
	return nil
}

func (cc *ContentfulClient) UpdateCache(ctx context.Context, contentTypes []string, cacheAssets bool) error {
	start := time.Now()
	if cc.clientMode != ClientModeCDA {
		return errors.New("UpdateCache: Only available in ClientModeCDA")
	}
	tempCache := &ContentfulCache{
		ContentTypes:     contentTypes,
		IdContentTypeMap: map[string]string{},
		ParentMap:        map[string][]EntryReference{},
	}
	for _, contentType := range contentTypes {
		if !stringSliceContains(spaceContentTypes, contentType) {
			return fmt.Errorf("UpdateCache: Content Type %q not available in this space", contentType)
		}
	}
	if cacheAssets {
		contentTypes = append([]string{assetWorkerType}, contentTypes...)
	}
	results := make(chan ContentTypeResult, 16)
	resultsDone := make(chan struct{})
	contentTypeChan := make(chan string)
	group, gctx := errgroup.WithContext(ctx)
	for i := 0; i < cacheUpdateConcurrency; i++ {
		group.Go(func() error {
			for contentType := range contentTypeChan {
				if err := updateCacheForContentType(gctx, results, cc, tempCache, contentType); err != nil {
					return err
				}
			}
			return nil
		})
	}
	go func() {
		for _, contentType := range contentTypes {
			contentTypeChan <- contentType
		}
		close(contentTypeChan)
	}()
	go func() {
		for res := range results {
			tempCache.IdContentTypeMap[res.EntryID] = res.ContentType
			for childID, references := range res.References {
				tempCache.ParentMap[childID] = append(tempCache.ParentMap[childID], references...)
			}
		}
		resultsDone <- struct{}{}
	}()
	err := group.Wait()
	close(results)
	if err != nil {
		// drain contentTypeChan
		for _ = range contentTypeChan {	}
		return err
	}
	// Signal that the cache build is done
	<-resultsDone

	if cc.logFn != nil && cc.logLevel <= LogInfo {
		cc.logFn(map[string]interface{}{"time elapsed":time.Since(start), "method": "UpdateCache"}, LogInfo, InfoUpdateCacheTime)
	}
	cc.Cache = tempCache
	return nil
}

func (cc *ContentfulClient) GetContentTypeOfID(id string) (string, error) {
	if cc.Client == nil {
		return "", errors.New("GetContentTypeOfID: No client available")
	}
	if cc.Cache != nil {
		okVo := false
		{{ range $index , $contentType := $contentTypes }}
		_, okVo = cc.Cache.EntryMaps.{{ firstCap $contentType.Sys.ID }}[id]
		if okVo {
			return ContentType{{ firstCap $contentType.Sys.ID }}, nil
		}
		{{ end }}
	}
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.Include(0).Equal("sys.id",id)
	if _, err := col.GetAll(); err != nil {
		return "", fmt.Errorf("GetContentTypeOfID: %w", err)
	}
	if len(col.Items) == 0 {
		return "", fmt.Errorf("GetContentTypeOfID: %s Not found", id)
	}
	vo := new(genericEntryNoFields)
	if err := transcodeJSON(col.Items[0], vo); err != nil {
		return err
	}
	return vo.Sys.ContentType.Sys.ID, nil
}


func (cc *ContentfulClient) optimisticPageSizeGetAll(contentType string, limit uint16) (*contentful.Collection, error) {
	col := cc.Client.Entries.List(cc.SpaceID)
	col.Query.ContentType(contentType).Locale("*").Include(0).Limit(limit)
	allItems := []interface{}{}
	var err error
	for {
		if _, err = col.Next(); err != nil {
			break
		}
		allItems = append(allItems, col.Items...)
		if uint16(len(col.Items)) < limit {
			break
		}
	}
	col.Items = allItems
	if err != nil {
		msg := err.(contentful.ErrorResponse).Message
		if strings.Contains(msg, "Response size too big") && limit >= 20 {
			smallerPageCol, err := cc.optimisticPageSizeGetAll(contentType, limit / 2 )
			return smallerPageCol, err
		}
		return nil, err
	}
	return col, nil
}

// Asset utils
func (cc *ContentfulClient) getAllAssets(tryCacheFirst bool) (map[string]*contentful.Asset, error) {
	if cc.Client == nil {
		return nil, errors.New("getAllAssets: No client available")
	}
	if cc.Cache != nil && cc.Cache.Assets != nil && tryCacheFirst {
		return cc.Cache.Assets, nil
	}
	col := cc.Client.Assets.List(cc.SpaceID)
	col.Query.Locale("*").Limit(assetPageSize)
	assets := map[string]*contentful.Asset{}
	allItems := []interface{}{}
	for {
		if _, err := col.Next(); err != nil {
			return nil, err
		}
		allItems = append(allItems, col.Items...)
		if uint16(len(col.Items)) < assetPageSize {
			break
		}
	}
	for _, item := range allItems {
		asset := new(contentful.Asset)
		if err := transcodeJSON(item, asset); err != nil {
			return nil, err
		}
		for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
			if _, ok := asset.Fields.File[string(loc)]; ok {
				asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
			}
		}
		assets[asset.Sys.ID] = asset
	}
	return assets, nil
}
func (cc *ContentfulClient) GetAllAssets() (map[string]*contentful.Asset, error) {
	return cc.getAllAssets(true)
}
func (cc *ContentfulClient) GetAssetByID(id string) (*contentful.Asset, error) {
	if cc.Client == nil {
		return nil, errors.New("GetAssetByID: No client available")
	}
	if cc.Cache != nil && cc.Cache.Assets != nil {
		asset, okAsset := cc.Cache.Assets[id]
		if okAsset {
			return asset, nil
		}
	}
	col := cc.Client.Assets.List(cc.SpaceID)
	col.Query.Locale("*").Equal("sys.id",id)
	if _, err := col.Next(); err != nil {
		return nil, err
	}
	if len(col.Items) == 0 {
		return nil, errors.New("GetAssetByID: Not found "+ id)
	}
	item := col.Items[0]
	asset := new(contentful.Asset)
	if err := transcodeJSON(item, asset); err != nil {
		return err
	}
	for _, loc := range []Locale{ {{ range $index , $locale := $locales }}SpaceLocale{{ onlyLetters $locale.Name }},{{end}} } {
		if _, ok := asset.Fields.File[string(loc)]; ok {
			asset.Fields.File[string(loc)].URL = "https:" + asset.Fields.File[string(loc)].URL
		}
	}
	return asset, nil
}

func NewAssetFromURL(id string, uploadUrl string, imageFileType string, title string, locale ...Locale) *contentful.Asset {
	autoID := fmt.Sprintf("%d", time.Now().UnixNano()/int64(time.Millisecond))
	if id == "" {
		id = autoID
	}
	if title == "" {
		title = id
	}
	var loc Locale
	if len(locale) != 0 {
		loc = locale[0]
		if localeFallback[loc]!="" {
			return nil
		}
	} else {
		loc = defaultLocale
	}
	asset := &contentful.Asset{
		Sys: &contentful.Sys{
			ID: id,
		},
		Fields: &contentful.FileFields{
			File: map[string]*contentful.File{
				string(loc): {
					UploadURL:   uploadUrl,
					ContentType: imageFileType,
					Name:        id,
				},
			},
			Title: map[string]string{
				string(loc): title,
			},
		},
	}
	return asset
}

func ToAssetReference(asset *contentful.Asset) (refSys ContentTypeSys) {
	refSys.Sys.ID = asset.Sys.ID
	refSys.Sys.Type = FieldTypeLink
	refSys.Sys.LinkType = FieldLinkTypeAsset
	return
}

func (cc *ContentfulClient) DeleteAsset(asset *contentful.Asset) error {
	if cc.Client == nil {
		return errors.New("DeleteAsset: No client available")
	}
	if cc.clientMode != ClientModeCMA {
		return errors.New("DeleteAsset: Only available in ClientModeCMA")
	}
	if err := cc.Client.Assets.Unpublish(cc.SpaceID, asset); err != nil &&
		!strings.Contains(err.Error(), "Not published") {
		return err
	}
	return cc.Client.Assets.Delete(cc.SpaceID, asset)
}

// RichText utils

func HtmlToRichText(htmlSrc string) *RichTextNode {
	htmlClean := strings.TrimSpace(htmlSrc)
	htmlClean = strings.ReplaceAll(htmlClean, `&nbsp;`, ` `)
	htmlClean = strings.ReplaceAll(htmlClean, "\t", "")
	htmlClean = regexp.MustCompile(`[\s]{2,}`).ReplaceAllString(htmlClean, " ")
	re := regexp.MustCompile(`>([^\n])`)
	htmlClean = re.ReplaceAllString(htmlClean, fmt.Sprintf(">\n"+`$1`))
	re = regexp.MustCompile(`(.{1})<`)
	htmlClean = re.ReplaceAllString(htmlClean, `$1`+fmt.Sprintf("\n<"))
	htmlLines := strings.Split(htmlClean, "\n")
	rtnd := &RichTextNode{
		NodeType: RichTextNodeDocument,
	}
	var isBasic bool
	rtnd.Content, _, isBasic = htmlLinesToRichTextNode(htmlLines, 0, "", nil, true)
	if isBasic {
		basicRich := &RichTextNode{
			NodeType: RichTextNodeDocument,
		}
		par := RichTextNode{
			NodeType: RichTextNodeParagraph,
		}
		par.Content = rtnd.Content
		basicRich.Content = append(basicRich.Content, par)
		return basicRich
	}
	return rtnd
}

func getMark(mark string) string {
	switch mark {
	case HtmlItalic, HtmlEm:
		return RichTextMarkItalic
	case HtmlBold, HtmlStrong:
		return RichTextMarkBold
	case HtmlUnderline:
		return RichTextMarkUnderline
	case HtmlCode:
		return RichTextMarkCode
	}
	return ""
}

func getAttribute(htmlLine string, attribute string) string {
	re := regexp.MustCompile(` href=["']([^"']+)["']`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func htmlLinesToRichTextNode(htmlLines []string, start int, pendingTag string, marks []string, isBasic bool) ([]interface{}, int, bool) {
	nodeSlice := make([]interface{}, 0)
	for i := start; i < len(htmlLines); i++ {
		htmlLine := htmlLines[i]
		if isClosingPending(htmlLine, pendingTag) {
			return nodeSlice, i, isBasic
		}
		currentNode := RichTextNode{}
		if isTag(htmlLine) {
			tt := tagType(htmlLine)
			switch tt {
			case HtmlParagraph, HtmlHeading1, HtmlHeading2, HtmlHeading3, HtmlHeading4, HtmlHeading5, HtmlHeading6, HtmlUnorderedList, HtmlOrderedList:
				isBasic = false
				currentNode.NodeType = mapTagRichTextNodeType(tt)
				var nextLine int
				currentNode.Content, nextLine, isBasic = htmlLinesToRichTextNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlBlockquote, HtmlListItem:
				isBasic = false
				currentNode.NodeType = mapTagRichTextNodeType(tt)
				currentNode.Content = make([]interface{}, 0)
				innerContent, nextLine, isBasic := htmlLinesToRichTextNode(htmlLines, i+1, tt, marks, isBasic)
				currentNode.Content = append(currentNode.Content, RichTextNode{
					NodeType: RichTextNodeParagraph,
					Content:  innerContent,
				})
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlCode:
				isBasic = false
				currentNode.NodeType = RichTextNodeParagraph
				var nextLine int
				currentNode.Content, nextLine, isBasic = htmlLinesToRichTextNode(htmlLines, i+1, HtmlCode, []string{HtmlCode}, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlAnchor:
				isBasic = false
				currentNode.NodeType = RichTextNodeHyperlink
				var nextLine int
				anchorURI := getAttribute(htmlLine, HtmlAttributeHref)
				if anchorURI == "" {
					anchorURI = "/"
				}
				currentNode.Data = RichTextData{URI: anchorURI}
				currentNode.Content, nextLine, isBasic = htmlLinesToRichTextNode(htmlLines, i+1, tt, marks, isBasic)
				nodeSlice = append(nodeSlice, currentNode)
				if nextLine == -1 {
					return nodeSlice, -1, isBasic
				}
				i = nextLine
			case HtmlHorizontalRule:
				isBasic = false
				currentNode.NodeType = RichTextNodeHR
				currentNode.Content = make([]interface{}, 0)
				nodeSlice = append(nodeSlice, currentNode)
			case HtmlItalic, HtmlEm, HtmlBold, HtmlStrong, HtmlUnderline:
				marks = append(marks, tt)
			case HtmlBreak:
				if len(nodeSlice) > 0 {
					myNode := nodeSlice[len(nodeSlice)-1]
					switch myNode.(type) {
					case RichTextNodeTextNode:
						myNodeTyped := myNode.(RichTextNodeTextNode)
						if myNodeTyped.NodeType == RichTextNodeText {
							myNodeTyped.Value += "\n"
							nodeSlice[len(nodeSlice)-1] = myNodeTyped
						}
					}
				}
			}
			continue //unsupported tags will be ignored but content is preserved
		}
		if isClosingTag(htmlLine) {
			continue //closing tags that are not pending equal to unknown
		}
		if htmlLine == " " {
			continue
		}
		currentNodeTextNode := RichTextNodeTextNode{}
		currentNodeTextNode.NodeType = RichTextNodeText
		currentNodeTextNode.Marks = []RichTextMark{}
		currentNodeTextNode.Value = htmlLine
		for _, mark := range marks {
			currentNodeTextNode.Marks = append(currentNodeTextNode.Marks, RichTextMark{
				Type: getMark(mark),
			})
		}
		marks = nil
		nodeSlice = append(nodeSlice, currentNodeTextNode)
	}
	return nodeSlice, -1, isBasic
}

func isClosingPending(htmlLine, tag string) bool {
	return regexp.MustCompile(`</` + strings.ToLower(tag) + `.+$`).MatchString(strings.ToLower(htmlLine))
}

func isClosingTag(htmlLine string) bool {
	return regexp.MustCompile(`</[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func isTag(htmlLine string) bool {
	return regexp.MustCompile(`<[a-zA-Z]+.+$`).MatchString(htmlLine)
}

func mapTagRichTextNodeType(tag string) string {
	switch tag {
	case HtmlParagraph:
		return RichTextNodeParagraph
	case HtmlAnchor:
		return RichTextNodeHyperlink
	case HtmlHeading1:
		return RichTextNodeHeading1
	case HtmlHeading2:
		return RichTextNodeHeading2
	case HtmlHeading3:
		return RichTextNodeHeading3
	case HtmlHeading4:
		return RichTextNodeHeading4
	case HtmlHeading5:
		return RichTextNodeHeading5
	case HtmlHeading6:
		return RichTextNodeHeading6
	case HtmlBlockquote:
		return RichTextNodeBlockquote
	case HtmlUnorderedList:
		return RichTextNodeUnorderedList
	case HtmlOrderedList:
		return RichTextNodeOrderedList
	case HtmlListItem:
		return RichTextNodeListItem
	}
	return ""
}

func tagType(htmlLine string) string {
	re := regexp.MustCompile(`^<([a-zA-Z0-9]+)[\s]*>*`)
	matches := re.FindStringSubmatch(htmlLine)
	if len(matches) == 2 {
		return strings.ToLower(matches[1])
	}
	return ""
}

func (ts htmlTags) open(w io.Writer) {

	for _, t := range ts {
		tagString := "<" + t.name
		if len(t.attrs) > 0 {
			for name, value := range t.attrs {
				tagString += " " + name + `="` + html.EscapeString(value) + `"`
			}
		}
		_, _ = w.Write([]byte(tagString + ">"))
	}
}

func (ts htmlTags) close(w io.Writer) {
	for _, t := range ts {
		_, _ = w.Write([]byte("</" + t.name + ">"))
	}
}

type LinkResolverFunc func(url string) (resolvedURL string, resolveError error)
type ImageResolverFunc func(assetID string) (attrs map[string]string, resolveError error)

func (n *RichTextGenericNode) renderHTML(w io.Writer, linkResolver LinkResolverFunc, imageResolver ImageResolverFunc) error {
	if linkResolver == nil {
		linkResolver = func(url string) (string, error) { return url, nil }
	}

	tags := htmlTags{}

	switch n.NodeType {
	case RichTextNodeParagraph:
		tags = []htmlTag{ {name: HtmlParagraph} }
	case RichTextNodeHeading1:
		tags = []htmlTag{ {name: HtmlHeading1} }
	case RichTextNodeHeading2:
		tags = []htmlTag{ {name: HtmlHeading2} }
	case RichTextNodeHeading3:
		tags = []htmlTag{ {name: HtmlHeading3} }
	case RichTextNodeHeading4:
		tags = []htmlTag{ {name: HtmlHeading4} }
	case RichTextNodeHeading5:
		tags = []htmlTag{ {name: HtmlHeading5} }
	case RichTextNodeHeading6:
		tags = []htmlTag{ {name: HtmlHeading6} }
	case RichTextNodeOrderedList:
		tags = []htmlTag{ {name: HtmlOrderedList} }
	case RichTextNodeUnorderedList:
		tags = []htmlTag{ {name: HtmlUnorderedList} }
	case RichTextNodeListItem:
		tags = []htmlTag{ {name: HtmlListItem} }
	case RichTextNodeHR:
		tags = []htmlTag{ {name: HtmlHorizontalRule} }
	case RichTextNodeBlockquote:
		tags = []htmlTag{ {name: HtmlBlockquote} }
	case RichTextNodeText:
		tags = []htmlTag{}
	case RichTextNodeHyperlink:
		uri, _ := n.Data["uri"]
		attrs := map[string]string{}
		switch uri.(type) {
		case string:
			uriString := uri.(string)
			if uriString != "" {
				resolvedURL, errResolveURL := linkResolver(uriString)
				if errResolveURL != nil {
					err = errResolveURL
					return
				}

				attrs["href"] = resolvedURL
			}

		}
		tags = []htmlTag{htmlTag{name: HtmlAnchor, attrs: attrs}}
	case RichTextNodeEmbeddedAsset:
		if imageResolver == nil {
			return errors.New("Can't resolve image asset URL")
		}
		dataObj := new(RichTextData)
		if err := transcodeJSON(n.Data, dataObj); err != nil {
			return err
		}
		if dataObj.Target == nil {
			return errors.New("Data target is empty")
		}
		attrs, err := imageResolver(dataObj.Target.Sys.ID)
		if err != nil {
			return err
		}
		tags = []htmlTag{htmlTag{name: HtmlImage, attrs: attrs}}
	default:
	}
	for _, m := range n.Marks {
		markTag := ""
		switch m.Type {
		case RichTextMarkBold:
			markTag = HtmlBold
		case RichTextMarkItalic:
			markTag = HtmlItalic
		case RichTextMarkUnderline:
			markTag = HtmlUnderline
		case RichTextMarkCode:
			markTag = HtmlCode
		case RichTextNodeBlockquote:
			markTag = HtmlBlockquote
		}
		if markTag != "" {
			tags = append(tags, htmlTag{name: markTag})
		}
	}

	tags.open(w)
	_, _ = w.Write([]byte(strings.Replace(html.EscapeString(n.Value), "\n", "<br/>", -1)))
	for _, subNode := range n.Content {
		if err := subNode.renderHTML(w, linkResolver, imageResolver); err != nil {
			return err
		}
	}
	tags.close(w)
	return nil
}

func RichTextToHtml(rt interface{}, linkResolver LinkResolverFunc, imageResolver ImageResolverFunc) (string, error) {
	w := bytes.NewBuffer([]byte{})
	node := new(RichTextGenericNode)
	if err := transcodeJSON(rt, node); err != nil {
		return err
	}
	if err := node.renderHTML(w, linkResolver, imageResolver); err != nil {
		return "", err
	}
	out := w.String()
	if out == "<p></p>" {
		return "", nil
	}
	return out, nil
}

// Other utils

func (ref ContentfulReferencedEntry) ContentType() (contentType string) {
	return ref.Entry.Sys.ContentType.Sys.ID
}

func stringSliceContains(s []string, e string) bool {
	for _, a := range s {
		if a == e {
			return true
		}
	}
	return false
}
